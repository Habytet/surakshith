import 'package:flutter/foundation.dart';
import 'package:surakshith/data/models/task_template_model.dart';
import 'package:surakshith/data/models/notification_model.dart';
import 'package:surakshith/data/repositories/task_template_repository.dart';
import 'package:surakshith/data/repositories/task_repository.dart';
import 'package:surakshith/data/repositories/notification_repository.dart';

/// Service for generating tasks from repetitive task templates
/// This should ideally run daily via a background service or cron job
class RepetitiveTaskGenerator {
  final TaskTemplateRepository _templateRepository = TaskTemplateRepository();
  final TaskRepository _taskRepository = TaskRepository();
  final NotificationRepository _notificationRepository = NotificationRepository();

  /// Generate all tasks that are due today from active templates
  /// Returns the number of tasks created
  Future<TaskGenerationResult> generateDailyTasks() async {
    try {
      final result = TaskGenerationResult();

      // Get all templates that should generate tasks today
      final templates = await _templateRepository.getTemplatesForToday();

      if (templates.isEmpty) {
        debugPrint('No templates need task generation today');
        return result;
      }

      debugPrint('Found ${templates.length} templates to process');

      // Generate tasks for each template
      for (final template in templates) {
        try {
          final tasksCreated = await _generateTasksFromTemplate(template);
          result.successCount += tasksCreated;
          result.processedTemplates.add(template.id);
        } catch (e) {
          debugPrint('Error generating tasks for template ${template.id}: $e');
          result.failureCount++;
          result.errors.add('Template ${template.title}: $e');
        }
      }

      debugPrint(
        'Task generation complete: ${result.successCount} created, ${result.failureCount} failed',
      );

      return result;
    } catch (e) {
      debugPrint('Error in daily task generation: $e');
      return TaskGenerationResult()..errors.add('Fatal error: $e');
    }
  }

  /// Generate tasks from a specific template
  /// Returns the number of tasks created
  Future<int> _generateTasksFromTemplate(TaskTemplateModel template) async {
    int tasksCreated = 0;
    final now = DateTime.now();

    // Generate task for each default assignee
    for (final assigneeEmail in template.defaultAssignees) {
      try {
        // Generate the task from template
        final task = template.generateTask(
          assignees: [assigneeEmail],
        );

        // Create the task in Firestore
        final taskId = await _taskRepository.createTask(task);

        if (taskId != null) {
          tasksCreated++;

          // Create notification for the assignee
          await _createTaskAssignmentNotification(
            assigneeEmail: assigneeEmail,
            taskTitle: task.title,
            taskId: taskId,
          );
        }
      } catch (e) {
        debugPrint('Error creating task for $assigneeEmail: $e');
        // Continue with other assignees even if one fails
      }
    }

    // Update the template's last generated timestamp
    if (tasksCreated > 0) {
      await _templateRepository.updateLastGenerated(template.id, now);
    }

    return tasksCreated;
  }

  /// Create a notification for task assignment
  Future<void> _createTaskAssignmentNotification({
    required String assigneeEmail,
    required String taskTitle,
    required String taskId,
  }) async {
    try {
      final notification = NotificationModel.taskAssigned(
        id: '', // Will be generated by Firestore
        userId: assigneeEmail,
        taskId: taskId,
        taskTitle: taskTitle,
        assignedBy: 'System',
      );

      await _notificationRepository.createNotification(notification);
    } catch (e) {
      debugPrint('Error creating notification: $e');
      // Don't fail task creation if notification fails
    }
  }

  /// Generate tasks from a specific template (manual trigger)
  Future<int> generateTasksFromTemplate({
    required String templateId,
    DateTime? dueDate,
    List<String>? assignees,
  }) async {
    try {
      final template = await _templateRepository.getTemplateById(templateId);

      if (template == null) {
        debugPrint('Template $templateId not found');
        return 0;
      }

      if (!template.isActive) {
        debugPrint('Template ${template.title} is not active');
        return 0;
      }

      int tasksCreated = 0;
      final targetAssignees = assignees ?? template.defaultAssignees;

      for (final assigneeEmail in targetAssignees) {
        try {
          final task = template.generateTask(
            assignees: [assigneeEmail],
            dueDate: dueDate,
          );

          final taskId = await _taskRepository.createTask(task);

          if (taskId != null) {
            tasksCreated++;
            await _createTaskAssignmentNotification(
              assigneeEmail: assigneeEmail,
              taskTitle: task.title,
              taskId: taskId,
            );
          }
        } catch (e) {
          debugPrint('Error creating task for $assigneeEmail: $e');
        }
      }

      return tasksCreated;
    } catch (e) {
      debugPrint('Error generating tasks from template: $e');
      return 0;
    }
  }

  /// Check if any templates need tasks generated and return count
  Future<int> getTemplatesNeedingGeneration() async {
    try {
      final templates = await _templateRepository.getTemplatesForToday();
      return templates.length;
    } catch (e) {
      debugPrint('Error checking templates: $e');
      return 0;
    }
  }
}

/// Result of task generation operation
class TaskGenerationResult {
  int successCount = 0;
  int failureCount = 0;
  List<String> processedTemplates = [];
  List<String> errors = [];

  bool get hasErrors => errors.isNotEmpty;
  int get totalProcessed => successCount + failureCount;
}
